# AtCoder 解法パターンカタログ

## 目次
- [1. N が極端に小さい (N ≤ 20)](#1)
- [2. N が中くらい (N ≤ 50〜500)](#2)
- [3. N が大きめ (N ≤ 2000〜3000)](#3)
- [4. N がかなり大きい (N ≤ 10⁵〜2×10⁵)](#4)
- [5. N が超巨大 (10⁹〜10¹⁸)](#5)
- [6. キーワード軸でのショートカット](#6)

---

<a id="1"></a>
## 1. N が極端に小さい (N ≤ 20)
**指数時間 (2^N, N!) を疑うゾーン。**

### A. 探索・全探索系
- **ビット全探索・部分集合**
  - (N≈20 / 選ぶ選ばない) -> `0..<1<<N` のループで全通り試す
- **順列全探索**
  - (N≈10 / 順番が重要) -> `Permutation` で全順列 (N!) を試す
- **半分全列挙**
  - (N≈40 / 2分割可能) -> `N/2` ずつ全列挙して片方をソートし、ぶつける
- **枝刈り探索**
  - (パズル / 制約が厳しい) -> DFSしつつ、明らかにダメな枝を切る

### B. DP・その他
- **ビットDP**
  - (N≈20 / 集合状態 / TSP) -> `dp[mask][last_v]`
- **3進数ビットDP**
  - (N≈15 / 使う・使わない・保留) -> 3の状態を持つビット(3進数)で管理

---

<a id="2"></a>
## 2. N が中くらい (N ≤ 50〜500)
**O(N^3) やフローが許されるゾーン。**

### A. DP系
- **区間DP**
  - (区間マージ / 取り除く) -> `dp[len][L]` 短い区間から更新
- **2次元DP (O(N^3))**
  - (i < j の間に k を挟む) -> 分割点 k を全探索するループ

### B. グラフ・フロー
- **ワーシャル・フロイド**
  - (N≤300 / 全点対間距離) -> 3重ループ `d[i][j] = min(d[i][j], ...)`
- **最大流・最小カット**
  - (N≤100 / 割り当て / 燃やす埋める) -> グラフ構築して `Dinic`

### C. 全探索
- **O(N^3) 全探索**
  - (N≤300 / 3重ループ) -> 10^7〜10^8 回なら単純ループで間に合う

---

<a id="3"></a>
## 3. N が大きめ (N ≤ 2000〜3000)
**O(N^2) が限界ライン。**

### A. DP系
- **2次元DP (O(N^2))**
  - (LCS / ナップサック / 編集距離) -> `dp[i][j]` の単純更新

### B. グラフ・幾何
- **全点対処理 (幾何)**
  - (N≤3000 / 最近点対) -> 全ペア (i, j) を見ても間に合う
- **BFS/DFS (密グラフ)**
  - (辺数がN^2) -> 隣接行列や密なグラフでも O(N^2) なら探索可能

---

<a id="4"></a>
## 4. N がかなり大きい (N ≤ 10⁵〜2×10⁵)
**O(N log N) または O(N) 必須。最頻出ゾーン。**

### A. 貪欲法 (Greedy)
> Essence: ソートで片側の条件を固定し、もう片方の判定だけで済ませる。

- **区間スケジューリング** (数を稼ぐ)
  - (重ならない最大数 / 壁壊し) -> **終了位置(R)昇順** でソートして貪欲
  - 注意: 開始位置(L)順や長さ順でソートするとWA
  - [Keyence2020B](../../Solved_Code/Journal/26-02-19/Keyence2020B.nim)（ロボットアーム）
- **区間被覆** (範囲を埋める)
  - (最小個数で覆う / 警備員) -> **開始位置(L)昇順** でソート、つながる中でR最大を選ぶ
  - [AWC006-D](../../Solved_Code/Journal/26-02-17/AWC0006D.nim) (警備員)
- **区間分割** (リソース最小化)
  - (会議室数 / スレッド数) -> **開始位置(L)昇順** でソート、終了時刻をヒープ管理
- **辞書順最小**
  - (辞書順で早いもの) -> 前から順に「置ける最小の文字」を置いていく

### B. 二分探索 (Binary Search)
- **答えで決め打ち**
  - (最大値の最小化) -> 答え X を仮定して `check(X)` (単調性必須)

### C. データ構造 (Data Structures)
- **Fenwick Tree / Segment Tree**
  - (1点更新・区間和 / 転倒数) -> 配列上の区間クエリを O(log N)
- **Lazy Segment Tree**
  - (区間更新・区間和) -> 遅延評価で範囲更新に対応
- **Heap / Set / Treap**
  - (K番目の値 / 中央値 / 削除挿入) -> PriorityQueue や平衡二分探索木

### D. グラフ・木 (Graph/Tree)
- **ダイクストラ / 01-BFS**
  - (非負重み最短路 / 0-1重み) -> PriorityQueue / Deque
- **Union-Find**
  - (連結性 / グループ分け) -> 集合の統合・判定 O(α(N))
- **木DP / 全方位木DP**
  - (木上のパス / 各頂点を根とする) -> 葉から集約 / 根から分配

### E. 線形時間テクニック
- **尺取り法**
  - (区間和がX以下 / 単調性) -> Rを進めて条件アウトならLを縮める
- **累積和 / いもす法**
  - (区間加算 / 静的な和) -> 差分をとって最後に累積

---

<a id="5"></a>
## 5. N が超巨大 (10⁹〜10¹⁸)
**O(√N) や O(log N) の数論・行列。**

### A. 数論
- **素因数分解 / 約数列挙**
  - (約数 / 倍数) -> √N までの探索
- **平方分割**
  - (クエリ処理 / √Nバケット) -> Nが小さくても重いクエリに有効

### B. 行列・DP高速化
- **行列累乗**
  - (線形漸化式 / Kが巨大) -> 遷移行列を作って `Mat^K`
- **桁DP**
  - (N以下の数え上げ / 桁制約) -> `dp[桁][未満フラグ][条件]`

### C. 数式・組み合わせ
- **包除原理**
  - (かつ・または / 集合の共通部分) -> `Σ (-1)^|S| * N(S)`
- **等差・等比数列の和**
  - (数列の和 / O(1)) -> ループではなく公式で計算

---

<a id="6"></a>
## 6. キーワード軸でのショートカット

| キーワード | 疑うべき手法 |
|---|---|
| **最大値の最小化** | 決め打ち二分探索 |
| **辞書順最小** | 前から貪欲 (Greedy) |
| **周期性 / K=10^18** | ダブリング / サイクル検出 |
| **XOR 最大化** | 線形基底 (Basis) / Trie |
| **絶対値の和 最小** | 中央値 (Median) |
| **二乗誤差の和 最小** | 平均値 (Mean) |
| **マンハッタン距離** | 45度回転 (x+y, x-y) |
| **ゲーム / 先手後手** | 後ろから解析 / Grundy数 |