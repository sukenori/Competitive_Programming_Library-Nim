# Competitive Programming Library (Nim)

## 計算量目安 (制限時間 2秒 ≈ 10<sup>8</sup> ops)

| 計算量オーダー | Nの目安 | 典型的な解法 |
| :--- | :--- | :--- |
| <small>O(N!)</small> | <small>N ≈ 8..10</small> | <small>順列全探索 (10! ≈ 3.6 × 10<sup>6</sup>)</small> |
| <small>O(2<sup>N</sup>)</small> | <small>N ≈ 20</small> | <small>bit全探索 (2<sup>20</sup> ≈ 10<sup>6</sup>)</small> |
| <small>O(N·2<sup>N</sup>)</small> | <small>N ≈ 20..22</small> | <small>bitDP, 高速ゼータ/メビウス変換</small> |
| <small>O(N·2<sup>N/2</sup>)</small> | <small>N ≈ 40</small> | <small>半分全列挙</small> |
| <small>O(N<sup>4</sup>)</small> | <small>N ≈ 50..60</small> | <small>4重ループDP</small> |
| <small>O(N<sup>3</sup>)</small> | <small>N ≈ 500</small> | <small>区間DP, Floyd-Warshall, 行列乗算, ガウス消去法</small> |
| <small>O(N<sup>2</sup>)</small> | <small>N ≈ 3000</small> | <small>2次元DP, 座標圧縮, 2重ループ全探索</small> |
| <small>O(N<sup>2</sup> log N)</small> | <small>N ≈ 1000</small> | <small>2要素固定して二分探索, 順列転倒数(工夫なし)</small> |
| <small>O(N√N)</small> | <small>N ≈ 10<sup>5</sup></small> | <small>Mo's Algorithm, 平方分割(Bucket)</small> |
| <small>O(N log N)</small> | <small>N ≈ 2·10<sup>5</sup></small> | <small>ソート, Dijkstra, SegmentTree, BIT, 分割統治, FFT/NTT</small> |
| <small>O(N)</small> | <small>N ≈ 10<sup>6</sup></small> | <small>累積和, 尺取り法, 木DP/DFS/BFS, UnionFind(ほぼ線形)</small> |
| <small>O(√N)</small> | <small>N ≈ 10<sup>12</sup></small> | <small>素数判定, 約数列挙, 平方分割(整数)</small> |
| <small>O(log N)</small> | <small>N ≈ 10<sup>18</sup></small> | <small>二分探索, 高速冪乗, GCD, 行列累乗</small> |
| <small>O(1)</small> | <small>-</small> | <small>算数/数学的考察, 構築, 偶奇判定</small> |


---



## Algorithm

- **[BinarySearch.nim](./Algorithm/BinarySearch.nim)** `O(log N)`
    - **`二分探索`**: 判定問題における解の決め打ちや単調性を利用した探索
    - **(l .. r).minLeftIt(pred)**: int
        - 条件 pred を満たす「最小」の整数を返す
        - [False, False, ..., True, True] のような単調性がある場合に使用
        - pred 内では変数 it を使用
    - **(l .. r).maxRightIt(pred)**: int
        - 条件 pred を満たす「最大」の整数を返す
        - [True, True, ..., False, False] のような単調性がある場合に使用
        - pred 内では変数 it を使用
    - **(l .. r).minLeftFloatIt(pred, iter=100)**: float
        - 条件 pred を満たす「最小」の実数値を返す
        - [False, False, ..., True, True] のような単調性がある場合に使用
        - pred 内では変数 it を使用、規定回数は100回
    - **(l .. r).maxRightFloatIt(pred, iter=100)**: float
        - 条件 pred を満たす「最大」の実数値を返す
        - [True, True, ..., False, False] のような単調性がある場合に使用
        - pred 内では変数 it を使用、規定回数は100回
- **[CumulativeSum.nim](./Algorithm/CumulativeSum.nim)** `O(N) / O(1)`
    - **`累積和`**: 配列の区間和を高速に計算（1次元/2次元/imos法）
    - **seq[T].cumSum**: CumSum[T]
        - 1次元累積和を構築する
    - **CumSum[T][l .. r]**: T
        - 区間 [l, r] (閉区間)の和を返す
    - **seq[seq[T]].cumSum**: CumSum2D[T]
        - 2次元累積和を構築する（行 h × 列 w）
    - **CumSum2D[T][h1 .. h2][w1 .. w2]**: T
        - 矩形領域 (h1, w1) × (h2, w2) の和を返す（2重ブラケット記法）
- **[Doubling.nim](./Algorithm/Doubling.nim)** `O(N log K) / O(log K)`
    - **`ダブリング`**: 関数の繰り返し適用を高速化（K回後の移動先など）
    - **nexts.doubling(max_steps = 1 shl 60)**: Doubling
        - ダブリングの前計算
        - nexts[i]: i の 1 ステップ先（移動不可は -1）
        - max_steps: 想定される最大ステップ数
    - **Doubling(start, k)**: int
        - start から k 回進んだ先のインデックスを返す
        - 到達不能な場合は -1
- **[InversionNumber.nim](./Algorithm/InversionNumber.nim)** `O(N log N)`
    - **`転倒数`**: 数列の反転数を高速計算（BIT+座標圧縮）
    - **seq[T].inversionNumber**: int
        - i < j かつ a[i] > a[j] となる (i, j) ペアの個数
- **[Mo.nim](./Algorithm/Mo.nim)** `O((N+Q)√N)`
    - **`Mo's Algorithm`**: クエリ平方分割で区間クエリをオフライン処理（最短雑巾がけ）
    - **initMo(n)**: Mo
        - Mo構造体を初期化
    - **mo.add(l, r)**: void
        - クエリ区間 [l, r] (閉区間、0-indexed) を追加
    - **mo.run(add, remove, process)**: void
        - クエリを処理する（ブロック内で状態管理し、各クエリに回答）
        - add: インデックス idx を現在区間に追加した時の処理
        - remove: インデックス idx を現在区間から削除した時の処理
        - process: クエリ番号 queryIdx に対する回答処理

- **[RunLength.nim](./Algorithm/RunLength.nim)** <small>O(N)</small>
    - **ランレングス圧縮**: 連続する要素を(値, 個数)の組に圧縮・復元
    - `runLengthEnc(openArray[T])`
        - `seq[(T, int)]` に圧縮
    - `runLengthDec(seq[(T, int)])`
        - 元の列に復元. Tがcharならstringを返す
- **[SlidingWindow.nim](./Algorithm/SlidingWindow.nim)** <small>O(N)</small>
    - **スライド最大値/最小値 (SWAG)**: 固定長区間の最大/最小を列挙
    - `slidingWindowMin(a, k)`
        - 長さ a.len - k + 1 の最小値列を返す
    - `slidingWindowMax(a, k)`
        - 長さ a.len - k + 1 の最大値列を返す
- **[TernarySearch.nim](./Algorithm/TernarySearch.nim)** <small>O(log N)</small>
    - **三分探索**: 下に凸(または上に凸)な関数の極値を探索
    - `minIt(Slice[int], op)` / `maxIt`
        - 整数範囲で極値を探索. 暗黙の `it` を使用
    - `floatMinIt(Slice[float], iter, op)`
        - 実数範囲で極値を探索.
- **[TwoPointers.nim](./Algorithm/TwoPointers.nim)** <small>O(N)</small>
    - **尺取り法**: 条件を満たす区間を左右のポインタで伸縮させながら探索
    - `twoPointersForMaxLen`
        - 条件を満たす最長区間の探索
    - `twoPointersForMinLen`
        - 条件を満たす最短区間の探索 (無ければ len+1)
    - `twoPointersForCount`
        - 条件を満たす区間の数え上げ
- **[TwoSum.nim](./Algorithm/TwoSum.nim)** <small>O(N)</small>
    - **Two Sum**: 和が特定のKになるペアを探索
    - `hasTwoSum(a, target)`
        - 存在判定 return bool
    - `twoSum(a, target)`
        - 見つかった最初のインデックス組 (i, j) を返す. なければ (-1, -1)
    - `findAllTwoSum(a, target)`
        - 全てのインデックス組を列挙

## DP

### Bitmask

- **[HamiltonianPath.nim](./DP/Bitmask/HamiltonianPath.nim)** <small>O(N<sup>2</sup> 2<sup>N</sup>)</small>
    - **ハミルトンパス**: すべての頂点を一度だけ通るパスの存在判定 (bitDP)
    - `countHamiltonianPaths(N, adj)`
        - パスの総数を数え上げ
    - `minHamiltonianPath(N, dist)`
        - 重み付きグラフでの最短パス（最小コスト）
    - `reconstructMinHamiltonianPath`
        - 最短パスの経路復元
- **[MatchingDP.nim](./DP/Bitmask/MatchingDP.nim)** <small>O(N 2<sup>N</sup>)</small>
    - **マッチングDP**: グラフ上の任意の辺集合におけるマッチング数え上げ
    - `countPerfectMatchings(N, adj)`
        - 完全マッチングの数え上げ
    - `minWeightPerfectMatching(N, dist)`
        - 最小重み完全マッチング
    - `maxWeightPerfectMatching(N, dist)`
        - 最大重み完全マッチング
- **[TSP.nim](./DP/Bitmask/TSP.nim)** <small>O(N<sup>2</sup> 2<sup>N</sup>)</small>
    - **巡回セールスマン問題**: すべての頂点を一度だけ通り始点に戻る最短経路 (bitDP)
    - `solveTSP(N, dist)`
        - TSPの最小コストを計算
    - `reconstructTSP(N, dist)`
        - TSPの最小コスト経路を復元

### Digit

- **[AutomatonDP.nim](./DP/Digit/AutomatonDP.nim)** <small>O(N·Size)</small>
    - **オートマトン桁DP**: オートマトンを受理する数値の個数
    - `initAutomaton(size, init, trans, accept)`
        - オートマトンの定義
    - `modAutomaton(m, r)`
        - mで割ってr余る数を受理するオートマトン
    - `solveDigitDP(dfa, S)`
        - 文字列S以下の整数でdfaに受理されるものの個数 (modint)
- **[DigitDP.nim](./DP/Digit/DigitDP.nim)** <small>O(N·State)</small>
    - **汎用桁DP**: コールバックによる自由な遷移定義
    - `solveDigitDP(S, maxState, ... walk)`
        - 状態遷移 `walk` に従い、S以下の数に対するDPを実行

### Expectation

- **[ExpectedValue.nim](./DP/Expectation/ExpectedValue.nim)**
    - **期待値DP**: ゴールまでの操作回数やコストの期待値計算
    - `solveExpectationDAG(N, goals, next_states)`
        - DAG上の期待値 (メモ化再帰)

### Interval

- **[MCM.nim](./DP/Interval/MCM.nim)** <small>O(N<sup>3</sup>)</small>
    - **連鎖行列積**: 行列の積の計算コスト最小化
    - `solveMCM(P)`: 次元配列Pに対応する最小コスト
- **[OptimalBST.nim](./DP/Interval/OptimalBST.nim)** <small>O(N<sup>3</sup>)</small>
    - **最適二分探索木**: 探索頻度に基づくコスト最小化
    - `solveOptimalBST(freq)`: 期待コスト最小値
- **[SlimeCombine.nim](./DP/Interval/SlimeCombine.nim)** <small>O(N<sup>3</sup>)</small>
    - **スライム合成**: 隣接要素併合コスト最小化 (累積和利用)
    - `solveSlimeCombine(a)`: 合成最小コスト

### Optimization

- **[CompressDP.nim](./DP/Optimization/CompressDP.nim)**
    - **座標圧縮**: DPの状態数削減、1次元座標圧縮
    - `initCompressor(vals)`: 圧縮器初期化
    - `c.get(val)`: 圧縮後の座標取得

### Select

- **[Knapsack.nim](./DP/Select/Knapsack.nim)** <small>O(NW)</small>
    - **ナップサック問題**: 0/1, 個数制限なし
    - `solveKnapsack01(w, v, W)`: 0/1ナップサック (価値最大化)
    - `solveKnapsackUnbounded(w, v, W)`: 個数制限なし
    - `solveKnapsackSmallV(w, v, W)`: 価値が小さい場合の最小重さDP
- **[SubsetSum.nim](./DP/Select/SubsetSum.nim)** <small>O(NK)</small>
    - **部分和問題**: 組み合わせで和を作れるか判定
    - `solveSubsetSum(a, K)`: 判定
    - `countSubsetSum(a, K)`: 数え上げ (MOD)
- **[WeightedIntervalScheduling.nim](./DP/Select/WeightedIntervalScheduling.nim)** <small>O(N log N)</small>
    - **重み付き区間スケジューリング**: 重ならない区間の最大重み和
    - `solveWeightedIntervalScheduling(intervals)`: 最大重み

### Sequence

- **[Kadane.nim](./DP/Sequence/Kadane.nim)** <small>O(N)</small>
    - **Kadane's Algorithm**: 最大部分配列和
    - `solveKadane(a)`: 連続部分列の最大和
- **[LIS.nim](./DP/LIS.nim)** `O(N log N)`
    - **最長増加部分列 (Longest Increasing Subsequence)**: 単調増加する最長の部分列を求める (厳密/非厳密)
    - **seq[T].lisLen(strict: bool = true)**: int
        - 配列の最長増加部分列の長さを求める
        - strict: true=厳密増加, false=非減少
    - **seq[T].lisIdx(strict: bool = true)**: seq[int]
        - 最長増加部分列を構成する要素のインデックス列を返す
        - strict: true=厳密増加, false=非減少
- **[StreakBonus.nim](./DP/Sequence/StreakBonus.nim)** <small>O(N<sup>2</sup>)</small>
    - **Streak Bonus**: 連続採用ボーナス付きDP
    - `solveStreakBonus(vals, bonus)`: 最大スコア

### String (DP)

- **[EditDistance.nim](./DP/String/EditDistance.nim)** <small>O(|S||T|)</small>
    - **編集距離 (Levenshtein)**: 文字列変換の最小操作回数
    - `editDistance(s, t)`
- **[LCS.nim](./DP/String/LCS.nim)** <small>O(|S||T|)</small>
    - **最長共通部分列 (LCS)**:
    - `solveLCS(s, t)`: LCS長
    - `reconstructLCS(s, t)`: LCS復元

### Tree

- **[IndependentSetTree.nim](./DP/Tree/IndependentSetTree.nim)** <small>O(N)</small>
    - **木の最大独立集合**: 隣接しない頂点の最大数
    - `solveIndependentSetTree(adj)`
- **[RerootingDP.nim](./DP/Tree/RerootingDP.nim)** <small>O(N)</small>
    - **全方位木DP**: 全頂点を根とした木DPを一括計算
    - `initRerooting`, `build`, `solve`: 汎用フレームワーク
- **[TreeDiameterDP.nim](./DP/Tree/TreeDiameterDP.nim)** <small>O(N)</small>
    - **木の直径**: 木の最遠点間距離
    - `getTreeDiameter(adj)`: 両端点と距離 (Double DFS)
    - `getTreeDiameterDP(adj)`: 距離のみ (Deepest Node DP)
- **[TreeDP.nim](./DP/Tree/TreeDP.nim)** <small>O(N)</small>
## Graph

- **[GraphTemplate.nim](./Graph/GraphTemplate.nim)**
    - **グラフテンプレート**: グラフ要素(`Edge`)、隣接リスト(`Graph`)の定義と便利入力
    - `initGraph(n)`, `addEdge(u, v, w)`
- **[BipartiteGraph.nim](./Graph/BipartiteGraph.nim)** <small>O(V+E)</small>
    - **二部グラフ**: 判定と彩色
    - `getBipartiteColoring(adj)`: 2彩色 (0/1) または空(不可)
- **[Connectivity](./Graph/Connectivity)**
    - **[LowLink.nim](./Graph/Connectivity/LowLink.nim)** <small>O(V+E)</small>
        - **LowLink**: 関節点と橋の列挙
        - `buildLowLink(adj)`
    - **[SCC.nim](./Graph/Connectivity/SCC.nim)** <small>O(V+E)</small>
        - **強連結成分分解 (SCC)**: Tarjan's Algo
        - `buildSCC(adj)`: 成分分解とトポロジカル順序
    - **[TopologicalSort.nim](./Graph/Connectivity/TopologicalSort.nim)** <small>O(V+E)</small>
        - **トポロジカルソート**: DAGの順序付け
        - `topologicalSort(adj)`
- **[Flow](./Graph/Flow)**
    - **[MaxFlow.nim](./Graph/Flow/MaxFlow.nim)** <small>O(V<sup>2</sup>E)</small>
        - **最大流 (Dinic)**:
        - `maxFlow(s, t)`
    - **[MinCostMaxFlow.nim](./Graph/Flow/MinCostMaxFlow.nim)**
        - **最小費用流 (Primal-Dual)**:
        - `minCostMaxFlow(s, t, f)`
- **[MST](./Graph/MST)**
    - **[Kruskal.nim](./Graph/MST/Kruskal.nim)** <small>O(E log E)</small>
        - **最小全域木 (Kruskal)**: UnionFind利用
        - `kruskal(edges)`
    - **[Prim.nim](./Graph/MST/Prim.nim)** <small>O(E log V)</small>
        - **最小全域木 (Prim)**: PriorityQueue利用
        - `prim(adj)`
- **[ShortestPath](./Graph/ShortestPath)**
    - **[BellmanFord.nim](./Graph/ShortestPath/BellmanFord.nim)** <small>O(VE)</small>
        - **Bellman-Ford / SPFA**: 負の辺があっても動作、負閉路検出
        - `bellmanFord(edges)`, `spfa(adj)`
    - **[Dijkstra.nim](./Graph/ShortestPath/Dijkstra.nim)** <small>O(E log V)</small>
        - **Dijkstra**: 非負閉路グラフの最短路
        - `dijkstra(adj, start)`
        - `dijkstraPath(adj, start, goal)`: 経路復元
    - **[WarshallFloyd.nim](./Graph/ShortestPath/WarshallFloyd.nim)** <small>O(V<sup>3</sup>)</small>
        - **Warshall-Floyd**: 全点対最短経路
        - `warshallFloyd(matrix)`
- **[Traversal](./Graph/Traversal)**
    - **[BFS.nim](./Graph/Traversal/BFS.nim)** <small>O(V+E)</small>
        - **幅優先探索**:
        - `bfs(adj, start)`, `bfs01(adj, start)`
    - **[DFS.nim](./Graph/Traversal/DFS.nim)** <small>O(V+E)</small>
        - **深さ優先探索**:
        - `dfs(adj)`, `dfsTimestamp(adj)` (行きがけ/帰りがけ)
- **[Tree](./Graph/Tree)**
    - **[Diameter.nim](./Graph/Tree/Diameter.nim)** <small>O(N)</small>
        - **木の直径**: Double BFS法
        - `getTreeDiameter(adj)`
    - **[HLD.nim](./Graph/Tree/HLD.nim)** <small>O(N)</small>
        - **Heavy-Light Decomposition**: パスをlog本の区間に分解
        - `initHLD(adj)`, `getPath(u, v)`, `getLCA(u, v)`
    - **[LCA.nim](./Graph/Tree/LCA.nim)** <small>O(N log N) / O(log N)</small>
        - **最小共通祖先**: ダブリング法
        - `initLCA(adj)`, `query(u, v)`, `getDist(u, v)`

## Math

### Algebra

- **[Rational.nim](./Math/Algebra/Rational.nim)**
    - **有理数**: 分数(有理数)の四則演算
    - `initRational(n, d)`, `+`, `-`, `*`, `/`

### Combinatorics

- **[Enumeration.nim](./Math/Combinatorics/Enumeration.nim)** <small>O(N) / O(1)</small>
    - **数え上げ**: 順列・組み合わせ・分割数や写像12相などの計算
    - `permutation(n, k)`: 順列 nPk
    - `integerPartitions(n, k)`: 整数の分割 (nをk個の正整数の和で表す)
    - `catalan(n)`: カタラン数 $C_n$
    - `stirling2(n, k)`: 第2種スターリング数 $S(n, k)$ (グループ分け)
    - `bell(n, k)`: ベル数 $B(n, k)$ (グループ分けの総数)

### Matrix

- **[Matrix.nim](./Math/Matrix/Matrix.nim)** <small>O(N<sup>3</sup>)</small>
    - **行列演算**: 行列の乗算・累乗
    - `*` (Mul), `^` (Pow), `identityMatrix`

### NumberTheory

- **[BaseConversion.nim](./Math/NumberTheory/BaseConversion.nim)** <small>O(log N)</small>
    - **進数変換**: N進数表記(string/seq)と整数の相互変換
    - `toBase(n, b)`, `fromBase(s, b)`, `baseConvert(s, n, m)`
- **[NumberTheory.nim](./Math/NumberTheory/NumberTheory.nim)** <small>O(√N)</small>
    - **整数論**: 素数判定、素因数分解、約数列挙、GCD/LCMなど
    - `isPrime`, `getDivisors`, `getPrimeFactors`
    - `gcd`, `lcm`, `extGcd`, `modInv`

## String

- **[Manacher.nim](./String/Manacher.nim)** <small>O(N)</small>
    - **Manacher法**: 文字列中の最長回文半径を線形時間で計算
- **[RollingHash.nim](./String/RollingHash.nim)** <small>O(N) / O(1)</small>
    - **ローリングハッシュ**: 文字列の一致判定や包含判定をハッシュで高速化
- **[ZAlgorithm.nim](./String/ZAlgorithm.nim)** <small>O(N)</small>
    - **Z-Algorithm**: 各接尾辞と全体の最長共通接頭辞長(LCP)を計算

## Structure

- **[FenwickTree.nim](./Structure/FenwickTree.nim)** <small>O(log N)</small>
    - **Binary Indexed Tree**: 一点加算と区間和を $O(\log N)$ で処理 (定数倍に優れる)
    - `add(i, x)`, `sum(i)`, `lowerBound(w)`
- **[GridUtils.nim](./Structure/GridUtils.nim)**
    - **グリッド探索ユーティリティ**: 2次元グリッド上の探索便利機能 (近傍探索、番兵など、メソッドチェーン対応)
    - `(h, w).neighbors`: 近傍探索開始
    - `.asDir8`: 4方向→8方向
    - `.inside(h, w)`: 範囲制限
    - `.on(grid)`: グリッド指定 (範囲制限含む)
    - `.skip('#')`: 通行不可マスを除外
    - `findAll(grid, 'S')`: 座標検索
    - `expandGrid('#')`: 番兵追加
- **[ImplicitTreap.nim](./Structure/ImplicitTreap.nim)** <small>O(log N)</small>
    - **Implicit Treap**: 配列に対する分割・結合・反転・挿入・削除を $O(\log N)$ で処理
- **[LazySegmentTree.nim](./Structure/LazySegmentTree.nim)** <small>O(log N)</small>
    - **遅延セグメント木**: 区間更新・区間取得を $O(\log N)$ で処理 (作用付きモノイド)
    - `apply(l, r, f)`, `prod(l, r)`, `set`, `get`
- **[SegmentTree.nim](./Structure/SegmentTree.nim)** <small>O(log N)</small>
    - **セグメント木**: 一点更新・区間取得を $O(\log N)$ で処理 (RMQ/RSQ、モノイド)
    - `set`, `get`, `prod`, `allProd`, `maxRight`, `minLeft`
- **[SortedMultiSet.nim](./Structure/SortedMultiSet.nim)** <small>O(log N)</small>
    - **順序付き多重集合**: 重複を許す要素の管理と順序検索
- **[SortedSet.nim](./Structure/SortedSet.nim)** <small>O(log N)</small>
    - **順序付き集合**: 重複を許さない要素の管理と順序検索
- **[SortedTable.nim](./Structure/SortedTable.nim)** <small>O(log N)</small>
    - **順序付きテーブル**: Key-Value管理
- **[Trie.nim](./Structure/Trie.nim)** <small>O(|S|)</small>
    - **トライ木**: 文字列集合の格納とプレフィックス検索
    - `add(s)`, `find(s)`, `countPrefix(s)`
- **[UnionFind.nim](./Structure/UnionFind.nim)** <small>O(α(N))</small>
    - **Union-Find**: 素集合の併合と連結判定 (閉路検出など)
    - `union(x, y)`, `find(x)`, `same(x, y)`, `size(x)`, `groups()`

## Template

- **[Template.nim](./Template.nim)**
    - **ユーティリティ集**: ModInt / Grid View1D/2D / sortedWithIdx / 組合せ・順列イテレータ / 座圧 / 二分探索補助  / ループ内包マクロ 等
    - **T.inf**
        - 型Tに応じた「十分大きい値」を返す。整数/浮動小数/有理数に対応
    - **bitアクセス: x[i], x[i] = b**
        - 整数xのi番目ビットを取得/設定 (0/1)。範囲外は未定義
    - **char@('a')**
        - 'a' からの0-index相対値
    - **char.parseInt**
        - parseIntはcharを整数へ
    - **int.isqrt**
        - floor(sqrt(n)) を返す。n>=0 を仮定
    - **a.chMax/chMin(b)**
        - a を b で更新し、更新が起きたら true を返す
    - **ModInt**
        - **initMod998244353 / initMod1000000007**
            - 代表的な法をmint環境として初期化（階乗APIも生成）
        - **initMod(m)**
            - 動的modの値を m に設定
        - **mint**
            - 法 M_VAL の ModInt 型エイリアス
        - **n.toMint**
            - int を法 M_VAL で正規化して mint に変換
        - **n.toDmint**
            - 動的modの ModInt に変換
        - **a.pow(p)**
            - a^p を計算 (繰り返し二乗法) `O(log p)`
        - **a.inv**
            - a の逆元を返す (フェルマーの小定理) ※Modは素数前提
        - **a.toInt**
            - ModInt を素の int に変換（暗黙/明示の両対応）
        - **fact(n) / invFact(n)**
            - 法 M_VAL での n! と (n!)^{-1} を返す
        - **n.dfact / dinvFact**
            - 動的modでの n! と (n!)^{-1} を返す
        - **modCombination(n,k) / modPermutation(n,k) / modHomogeneous(n,k)**
            - 静的modでの nCk, nPk, nHk を返す（kが範囲外なら0）
        - **dModCombination(n,k) / dModPermutation(n,k) / dModHomogeneous(n,k)**
            - 動的modでの nCk, nPk, nHk を返す（kが範囲外なら0）
    - **tuple.toSeq / seq.toTuple**
        - タプル ⇔ シーケンス変換ユーティリティ
    - **Seq[d1, d2, ... : init]**
        - 任意次元の配列を直感的に生成するDSL。右端の `init` で要素初期値/型を指定
    - **Grid**
        - **Pos**: tuple[h, w: int]
            - グリッド座標を表す型エイリアス
        - **Grid[T]**: object
            - 2次元配列を平坦化して保持する高速アクセス構造体
        - **initGrid(h, w, val)**
            - h × w の Grid[T] を val で初期化
        - **seq[seq[T]] / seq[string].toGrid**
            - 二次元配列 / 文字列配列を Grid[T] に変換（平坦化）
        - **Grid[T].idx(h, w) / Grid[T].idx(p: Pos)**
            - (h,w) 座標を平坦化インデックスに変換
        - **Grid[T].pos(i: int)**
            - 平坦化インデックスを (h, w) 座標に変換
        - **Grid[T].toSeq**: seq[seq[T]]
            - グリッドを二次元配列に変換（新規割り当て）
        - **Grid[T][h][w] / Grid[T][h][j] = val**
            - グリッド上の要素アクセス
    - **View1D / View2D**
        - **seq[T].view**: View1D
            - seqからO(1)でView1Dを生成
  ##- **View1D[T][i] / View1D[T][i] = val**
  ##    - ビュー上の要素に論理インデックスiでアクセス (物理位置は i - base)
        - **View1D[T].len**
            - ビューの長さを返す
  ##- **View1D[T].shift(k)**
  ##    - 物理メモリ(offset)は動かさず、論理インデックス(base)のみずらす
  ##    - shift(1) すると、アクセスは v[1]..v[len] になる
  ##- **View1D[T].start(s)**
  ##    - 物理的に先頭をs個切り落とす（offsetを進める）
  ##    - shiftはstartとは無関係で独立しているが、その後もshiftは維持される
        - **View1D[T].size(l)**
            - 長さをlに制限した部分ビュー
  ##- **View1D[T].step(k)**
  ##    - 間引き（物理ステップを変更）
  ##- **View1D[T].reverse**
  ##    - 反転ビューを返す
  ##    - shiftはreverseとは無関係で独立しているが、その後もshiftは維持される
  ##- **View1D[T].toSeq**
  ##    - 物理的に見えているデータを新規配列化 (base は無視)
        - **View1D.sort(order) / sort(cmp)**
            - ビュー範囲の要素をソートし、元データへ書き戻す
        - **View1D.circular**: CircularView1D[T]
            - インデックスを循環させてアクセスする1次元ビュー
        - **Grid[T].view**: View2D[T]
            - GridからO(1)でView2Dを生成
  ##- **View2D[T][i][j] / View2D[T][i][j] = val**
  ##    - 行アクセス、返されるView1Dには base_x が継承される
  ##    - 結果的にビュー上の要素アクセスとなる
  ##- **View2D[T].shift(dy, dx)**
  ##    - 物理メモリは動かさず、論理インデックスのみずらす
  ##- **View2D[T].start(y, x)**
  ##    - 左上位置を (y, x) から開始する部分ビュー
  ##    - shiftはstartとは無関係で独立しているが、その後もshiftは維持される
        - **View2D[T].size(h, w)**
            - ビューの高さと幅を制限した部分矩形
  ##- **View2D[T].swapXY**
  ##    - 転置ビューを返す（h↔w, st_y↔st_x を入れ替え）
  ##    - shiftのbaseは維持
  ##- **View2D[T].flipUD**
  ##    - 上下反転ビューを返す（要素はコピーしない）
  ##    - shiftのbaseは維持
  ##- **View2D[T].flipLR**
  ##    - 左右反転ビューを返す（要素はコピーしない）
  ##    - shiftのbaseは維持
  ##- **View2D[T].rotate90**
  ##    - 90度回転ビューを返す（h↔w, ストライド変換）
  ##    - shiftのbaseは維持
  ##- **View2D[T].toGrid**: Grid[T]
  ##    - 2Dビューをグリッドに新規変換（base は無視）
  ##- **View2D[T].toSeq**: seq[seq[T]]
  ##    - 2Dビューを新規二次元配列に変換（base は無視）
  ##- **View2D[T].rows**
  ##    - 各行をView1Dとして遅延列挙（base は無視）
        - **Grid[T].circular**: CircularView2D[T]
            - インデックスを循環させてアクセスする2次元ビュー
    - **openArray[T].sortedWithIdx(order=Ascending)**: SortedResult[T]
        - 配列をソートしつつ値/元インデックス/ランクを保持
        - **SortedResult[T].values**: seq[T]
            - ソート後の値の配列
        - **SortedResult[T].indeces**: seq[int]
            - 元インデックス（今のインデックス→元のインデックス）の配列
        - **SortedResult[T].ranks**: seq[int]
            - ランク（元のインデックス→今のインデックス）の配列
    - **openArray[T].indexer(mode = Compact)**: Indices[T]
        - 配列をソートしつつインデックス変換
        - Order: 重複ありモードと Compact: 重複なし（座標圧縮）モード
        - **Indices[T].val**: seq[T]
            - （圧縮）ソート後の値の配列
        - **Indices[T].orig**: seq[int]
            - 元インデックス（今のインデックス→元のインデックス、今そこにいるのは元のどこにいたものか）の配列
        - **Indices[T].rank**: seq[int]
            - 順位（元のインデックス→今のインデックス、元そこにいたものはソート後何番目になったか）の配列
        - **Indices[T].rankOf(val)**: int
            - 値 val に対応する順位を返す (見つからなければ -1)
        - **openArray[T].less/lessEqual/greater/greaterEqual(x)**: Bisect
            - ソート済み配列に対して条件を満たす範囲の先頭/末尾/要素の個数を返す
        - **Bisect.first**: int
            - 条件を満たす範囲の先頭のインデックス（該当する要素がない場合 -1）
        - **Bisect.last**: int
            - 条件を満たす範囲の末尾のインデックス（該当する要素がない場合 -1）
        - **Bisect.count**: int
            - 条件を満たす範囲の要素の個数
    - **iterator items(HSlice[int, int], step: int)**: int
        - スライスをstep幅で反復。上昇・下降を自動判定
    - **iterator perm(h, w: int / h, w, d:int): tuple[int, int] / tuple[int, int, int]
        - 0 ..< h, 0 .. <w, 0 ..< dの直積のtupleを返す
    - **iterator perm(s1, s2: Slice[int] / s1, s2, s3: Slice[int]): tuple[int, int] / tuple[int, int, int]
        - 各スライスの直積のtupleを返す
    ##- **iterator perm(seq[T], seq[T],..): seq[T]
  ##    - 各seqの直積のseqを返す
    ##- **iterator perm(int, int,..): seq[T]
  ##    - 各整数の0 ..< iの直積のseqを返す
    ##- **iterator perm(Slice[int], Slice[int],..): seq[[int]
  ##    - 各スライスの直積のseqを返す
    ##- **iterator perm(seq[T]): seq[T]
  ##    - seqの順列全列挙を返す
    ##- **iterator combs(n: int, r: static int): tuple[int, int] / tuple[int, int, int] / seq[int]
  ##    - 0 ..< n の中から、2つ / 3つ選ぶtuple / 4つ以上選ぶseqを返す
  ##- **iterator combs(Slice[int], r: static int): tuple[int, int] / tuple[int, int, int] / seq[int]
  ##    - スライスの中から、2つ / 3つ選ぶtuple / 4つ以上選ぶseqを返す
    ##- **iterator combs(openArray[T], r: static int): seq[[T]
  ##    - 配列の中から、r個選ぶseqを返す
  ##- **forElse(i, range, body)**
  ##    - forElseループが正常に終了したときだけElse節を実行
  ##- **loop(n)**
  ##    - n回の繰り返し処理
  ##- **query(count)**
  ##    - count回のクエリ処理
  ##    - op id: bodyの形式で分岐処理を記述
    ##- **sumOf(i, range, expr)**: T
  ##    - rangeの各iに対してexprを計算し、その**合計**を返す
    ##- **minOf(i, range, expr)**: T
  ##    - rangeの各iに対してexprを計算し、その**最小値**を返す
  ##- **maxOf(i, range, expr)**: T
  ##    - rangeの各iに対してexprを計算し、その**最大値**を返す

  ##- **mutable(x)**: var T
  ##    - const/immutableな値を可変参照に変換
  ##- **{.memoized.}**
  ##    - メモ化するプロシージャ。結果をグローバルテーブルにキャッシュ
  ##- **int / string / float.input**
  ##    - 標準入力の読み込み
  ##- **seq[int].input**
  ##    - seq[T]全体を標準入力から読み込み
  ##- **T.input(diff)**: T
  ##    - 入力値にdiffを足した値を返す
  ##- **tuple.input**
  ##    - タプル型の各フィールドを標準入力から読み込み
  ##- **asYesNo(body)**
  ##    - 条件式bodyを評価し、真なら"Yes"、偽なら"No"を出力
  ##- **dump(args) / `?=`**
  ##    - 変数名と値をstderrに出力（debug定義時のみ）
  ##    - `?=` は `=` の左辺の変数を dump
    ##- Edge[T]
  ##    - 汎用グラフの辺。重み T を持つ
  ##- WeightedUnionFind[T]
  ##    - 重み付きUnionFind (ポテンシャル付きUF)。ノード間の重み差(diff)を管理
  ##    - 基本機能: find(root取得), union(併合), weight(重み取得)
  ##- uf.find(i)
  ##    - 代表元（ルート）を検索しつつ経路圧縮を行う O(α(N))
  ##    - 判定: uf.find(u) == uf.find(v) なら同じグループ
    ##- uf.weight(i)
  ##    - 代表元に対する相対重みを取得
  ##    - 距離: uf.weight(v) - uf.weight(u) で u -> v 間の重み差を取得可能（同じグループの場合のみ有効）
    ##- uf.union(u, v, w)
  ##    - weight(v) - weight(u) = w となるように併合。矛盾があれば false を返す
  ##    - 既に同じグループの場合、整合性をチェックして結果を返す
    ##- uf.same(u, v)
  ##    - 同じグループか判定 O(α(N))
    ##- uf.isRoot(i)
  ##    - そのノードが代表元（ルート）か判定 O(1)
    ##- uf.size(i)
  ##    - 所属グループのサイズを取得 O(α(N))
    ##- uf.getGroups(n)
  ##    - 連結成分ごとの頂点リストを返す
  ##- GraphInfo[T]
  ##    - グラフの付加情報
  ##    - isTree: 木かどうか (連結かつ閉路なし)
  ##    - hasCycle: 閉路が存在するか (無向/弱連結として)
  ##    - isBipartite: 二部グラフ判定 (重み1として判定)
  ##    - isConsistent: 重み付きグラフとして矛盾がないか (閉路の重み和=0)
  ##    - uf: 構築過程で使用したWeightedUnionFind。連結性判定や距離計算に再利用可能
    ##- Graph[T]
  ##    - adj と info をまとめたグラフ本体
    ##- initGraph(n)
  ##    - ノード数 n のグラフを初期化
    ##- g.addEdge(u, v, w)
  ##    - 有向辺 u -> v (重み w) を追加し、GraphInfo も更新
    ##- g.addBiEdge(u, v, w)
  ##    - 無向辺 u <-> v (重み w) を追加し、GraphInfo も更新
    ##- iterator g.edges: tuple[u, v: int, weight: T]
  ##    - グラフ内の全辺を列挙 (u, v, w)
    ##- iterator g.edgesWithId: tuple[id, u, v: int, weight: T]
  ##    - ID付きで全辺を列挙 (id, u, v, w)
    ##- .to[] / .weight[]
  ##    - g.to[u]     : 隣接先だけの seq[int]
  ##    - g.weight[u] : (to, weight) タプルの seq
  ##- readGraph(n, m, weighted, directed, oneBased): Graph[T]
  ##    - 標準入力からグラフを構築して返す
  ##    - T が int/float かつ weighted=true なら重み w も読み込む
  ##    - weighted=false のときは常に重み1として扱う
